Name: Kieran Pichai

| Date    |       Time        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Update |
|:--------|:-----------------:|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Oct. 29 |  1:05pm - 1:55pm  |                                                                                                                                                                                                                                                                                            During this class block we did some initial testing: some ideas that we discussed as a group initially was using trees (binary search trees) to quickly search for values given a hash however this still wouldn't be very memory efficient. Secondly, I had this idea of using a hash map however after exploring the potential of this I realized there was a huge space tradeoff as even just for the barcode example our array would be 8+ terabytes. Towards the end of class me, Tony, and Isha started discussing our plan to maybe use a hash table which essentially stores hashes while allowing collisions. For example if we have on average 3-4 collisions at each place then we just store a arraylist or something at each position. |
| Oct. 30 | 10:30pm - 11:00pm | During this time I conceptualized the process of implementing this. Essentially step one is to create an array of p length, then for each element in the passed in reader we would read it in as a string, split it by commas, then add the key to the hash table at the specified index. However, in the case that there is a collision you want to add it to an arraylist stored at that location, since the average amount of collisions will be low you can ultimately just linear search through that. To search in this dataset after its created you would hash whatever your query is and go to that index. Then you would compare to the stored values, if there one just return that, other wise search through the rest. I think this workflow would solve this problem both efficiently (O(n) to set up and O(slightly greater than 1) to search) and space efficiently as it eliminates most if not all of the empty space found in just a huge array. I believe a polynomial rolling hash would be perfect for this application. |
| Oct. 31 | 10:55am - 11:25am |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              During this period of class I discussed the structuring of the hashtable with Tony and Isha more, we ran across an issue which is how we were going to search it however. This was solved by creating a Node object with would store a key value pair at each location in the hash table so that we could compare the keys then return the value. |
| Oct. 31 | 11:25am - 11:55am |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           I then worked on coding this solution. The first step however was creating the hash function that would be used and deciding on a prime. Me and Tony did some math on the board given the two contraints: being faster than binary search but also being more space efficient given we wouldn't have much memory space to work with (as allocated by the compiler). This ended up leading up to choosing a prime around 2.5 million. I coded the buffered reader and the poly rolling hash function. |
| Nov. 3  | 12:15pm - 1:00pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  I finished coding the product using a array of arraylists as my hash table. This seemed to work well however I got null pointer exceptions when I ran it on all the test cases. I fixed this by changing by add to hash table function by checking if the current arraylist at that index is null (if so creating the arraylist) to avoid this issue. I also improved my query method and checked if the thing you were searching for led to a hash that was null. I ran this new code on all the test cases and it worked pretty efficiently on all of them. |


To add a new row to the table, click into a cell and then hit shift-enter.