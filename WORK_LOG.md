Name: Kieran Pichai

| Date    |       Time        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Update |
|:--------|:-----------------:|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Oct. 29 |  1:05pm - 1:55pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         During this class block we did some initial testing: some ideas that we discussed as a group initially was using trees (binary search trees) to quickly search for values given a hash however this still wouldn't be very memory efficient. Secondly, I had this idea of using a hash map however after exploring the potential of this I realized there was a huge space tradeoff as even just for the barcode example our array would be 8+ terabytes. Towards the end of class me, Tony, and Isha started discussing our plan to maybe use a hash table which essentially stores hashes while allowing collisions. For example if we have on average 3-4 collisions at each place then we just store a arraylist or something at each position. |
| Oct. 30 | 10:30pm - 11:00pm |                                                                                                                                                                                                              During this time I conceptualized the process of implementing this. Essentially step one is to create an array of p length, then for each element in the passed in reader we would read it in as a string, split it by commas, then add the key to the hash table at the specified index. However, in the case that there is a collision you want to add it to an arraylist stored at that location, since the average amount of collisions will be low you can ultimately just linear search through that. To search in this dataset after its created you would hash whatever your query is and go to that index. Then you would compare to the stored values, if there one just return that, other wise search through the rest. I think this workflow would solve this problem both efficiently (O(n) to set up and O(slightly greater than 1) to search) and space efficiently as it eliminates most if not all of the empty space found in just a huge array. I believe a polynomial rolling hash would be perfect for this application. |
| Oct. 31 | 10:55am - 11:25am |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           During this period of class I discussed the structuring of the hashtable with Tony and Isha more, we ran across an issue which is how we were going to search it however. This was solved by creating a Node object with would store a key value pair at each location in the hash table so that we could compare the keys then return the value. |
| Oct. 31 | 11:25am - 11:55am |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        I then worked on coding this solution. The first step however was creating the hash function that would be used and deciding on a prime. Me and Tony did some math on the board given the two contraints: being faster than binary search but also being more space efficient given we wouldn't have much memory space to work with (as allocated by the compiler). This ended up leading up to choosing a prime around 2.5 million. I coded the buffered reader and the poly rolling hash function. |
| Nov. 3  | 12:15pm - 1:00pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               I finished coding the product using a array of arraylists as my hash table. This seemed to work well however I got null pointer exceptions when I ran it on all the test cases. I fixed this by changing by add to hash table function by checking if the current arraylist at that index is null (if so creating the arraylist) to avoid this issue. I also improved my query method and checked if the thing you were searching for led to a hash that was null. I ran this new code on all the test cases and it worked pretty efficiently on all of them. |
| Nov. 5  |  1:55pm - 2:25pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             During this session I began to code linear probing with a hashmap. I set down the baseline of the hashmap class and created the get, resize, and add functions. |
| Nov. 5  |   2:25 - 2:55pm   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 There isn't much to add as I basically just continued with the implementation of get resize and add (as seen in the time block above), however I did re order and think about the logic more. I have coded it so that the adding and resizing happen in tandem, everytime an element is added it checks to see if it violates the fill, if so it then resizes then re-hashes everything. I am having an issue with the tester that it won't let me input a node into query. |
| Nov. 6  | 10:00pm - 10:30pm |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         During this iteration, I fixed the previous issue which mainly just took tracing the get function to remove any possible null pointer exceptions. I then went through the test cases once more and found that my code was consistently returning invalid keys, no matter the input. |
| Nov. 10 |  3:00pm - 3:30pm  | During this block I fixed the reason my code was constantly returning INVALID KEY, this was because of a small silly error that in my buildTable function I never added anything to the hash table (as I had commented the line out). I added this one line back in and my code began to work on two test cases but failed to work on the other 2 (products, and stocks). I realized that this was because of my resize method which never checked if anything was null before re-adding and thus re-hashing it (causing nullpointerexceptions to occur). The reason this is an issue is because my max fill is 50%, so if i just loop through everything in the array and try to add it, at some point i'll try to add a null element (because that part in the array was originally empty). I fixed this and my code ran without errors on all test cases but still failed products and stocks as it returned INVALID KEY. Upon looking at my add and resize functions I realized that everytime I had to double the length of the array I reset the array by initializing it to a new value, essentially deleting all the previous info in the old array. After fixing this and storing a temp array the code works correctly on all the test cases now! |


To add a new row to the table, click into a cell and then hit shift-enter.